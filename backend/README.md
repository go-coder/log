# stderr 解决竞争的方案

log 前端部分采用只读类型解决了竞争问题，后端的竞争问题由后端自行解决。这里的解决思路同样是两个：只读、加锁（包括 chan 也是用到了锁）。

我们注意到，可能存在的竞争发生在调用 os.Stderr.WriteString 的时候，由于这不是一个原子操作，也就存在着一条日志没打完，另一条日志混入的情况。只读的解决办法看样子不行，我们这里考虑加互斥锁、或者使用 channel，下面比较一下两种方案的优势和不足：

使用 channel 的好处在于直观，所有的 log 请求被组织成了一个队列的形式，所有的日志汇集到了一个 goroutine 中进行处理；可能存在的问题是，当日志请求过多的时候，这个负责处理日志的 goroutine 可能会成为性能瓶颈。

加锁的话，日志请求在原来的 goroutine 中完成，避免了单个 goroutine 的性能我呢提，但是会影响当前 goroutine 的性能。

我们假定日志组织良好，不会达到 goroutine 性能瓶颈。这样，采用 channel 的方式排队处理请求，把日志处理从普通 goroutine 中提取出来，由专门的 goroutine 来处理，以期提高性能。
