package log

import (
	"fmt"
	"math"
	"reflect"
	"runtime"
	"time"

	"github.com/go-coder/logr"
	"github.com/spf13/pflag"
)

const (
	AutoGeneratedName = "<autoGeneratedName>"
)

var (
	argV int
)

func init() {
	pflag.IntVar(&argV, "v", math.MaxInt32, "threshold for info output")
	pflag.Parse()
}

type Outputer interface {
	Output(*Entry)
}

func New(outter Outputer) logr.Logger {
	return &rlog{
		level:  0,
		name:   "",
		fields: make([]interface{}, 0),
		outter: outter,
	}
}

func (l *rlog) copy() *rlog {
	return &rlog{
		level:  l.level,
		name:   l.name,
		fields: append(make([]interface{}, 0), l.fields...),
		outter: l.outter,
	}
}

type rlog struct {
	level  int
	name   string
	fields []interface{}
	outter Outputer
}

var _ logr.InfoLogger = (*rlog)(nil)
var _ logr.Logger = (*rlog)(nil)

func (l rlog) Enabled() bool {
	return l.level <= argV
}

func (l *rlog) Info(msg string, kvList ...interface{}) {
	if l.Enabled() {
		l.output(msg, kvList...)
	}
}

func (l *rlog) Error(err error, msg string, kvList ...interface{}) {
	if err != nil {
		kvList = append(kvList, "error", err.Error())
	} else {
		kvList = append(kvList, "error", ValueNil)
	}
	l.output(msg, kvList...)
}

func (l *rlog) V(level int) logr.InfoLogger {
	out := l.copy()
	out.level = level
	return out
}

func (l *rlog) WithName(name string) logr.Logger {
	out := l.copy()
	if out.name == "" {
		out.name = name
	} else {
		out.name = out.name + "/" + name
	}
	return out
}

func (l *rlog) WithFields(kvList ...interface{}) logr.Logger {
	out := l.copy()
	out.fields = append(out.fields, kvList...)
	return out
}

func (l *rlog) output(msg string, kvList ...interface{}) {
	if len(kvList)%2 != 0 {
		panic("fields must be key-value pairs")
	}
	// callDepth 0 represents current line
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = AutoGeneratedName
		line = 0
	}
	l.outter.Output(&Entry{
		Level:    l.level,
		Time:     time.Now(),
		FileName: file,
		LineNum:  line,
		Prefix:   l.name,
		Message:  msg,
		// attention that must be append(kvList, l.fields...) rather than append(l.fields, kvList...)
		Fields: kvListToMap(append(kvList, l.fields...)...),
	})
}

// kvList must be key-value pair
func kvListToMap(kvList ...interface{}) map[string]*TypedValue {
	dict := make(map[string]*TypedValue)
	for i := 0; i < len(kvList); i += 2 {
		key := kvList[i].(string)
		value := getTypedValue(kvList[i+1])
		dict[key] = value
	}
	return dict
}

func getTypedValue(v interface{}) *TypedValue {
	if v == nil {
		return &TypedValue{
			Type:  TypeNil,
			Value: ValueNil,
		}
	}
	if reflect.ValueOf(v).Kind() == reflect.Ptr {
		if reflect.ValueOf(v).IsNil() {
			return &TypedValue{
				Type:  reflect.TypeOf(v).String(),
				Value: ValueNil,
			}
		}
		v = reflect.Indirect(reflect.ValueOf(v)).Interface()
	}
	if reflect.ValueOf(v).Kind() == reflect.Chan {
		return &TypedValue{
			Type:  TypeChan,
			Value: ValueChan,
		}
	}
	return &TypedValue{
		Type:  fmt.Sprintf("%T", v),
		Value: fmt.Sprintf("%v", v),
	}
}
