package log

import (
	"fmt"
	"os"
	"reflect"
	"runtime"
	"sort"
	"strings"
	"time"

	"github.com/go-coder/logr"
	"github.com/spf13/pflag"
)

const (
	autoGeneratedName = "<autoGeneratedName>"
)

var (
	argV int
)

func init() {
	pflag.IntVar(&argV, "v", 2, "threshold for info output")
	pflag.Parse()
}

func New() logr.Logger {
	return &rlog{
		level:  0,
		name:   "",
		fields: make([]interface{}, 0),
	}
}

func (l *rlog) copy() *rlog {
	return &rlog{
		level:  l.level,
		name:   l.name,
		fields: append(make([]interface{}, 0), l.fields...),
	}
}

type rlog struct {
	level  int
	name   string
	fields []interface{}
}

var _ logr.InfoLogger = (*rlog)(nil)
var _ logr.Logger = (*rlog)(nil)

func (l rlog) Enabled() bool {
	return l.level <= argV
}

func (l *rlog) Info(msg string, kvList ...interface{}) {
	if l.Enabled() {
		l.output(msg, kvList...)
	}
}

func (l *rlog) Error(err error, msg string, kvList ...interface{}) {
	if err != nil {
		kvList = append(kvList, "error", err.Error())
	} else {
		kvList = append(kvList, "error", "nil")
	}
	l.output(msg, kvList...)
}

func (l *rlog) V(level int) logr.InfoLogger {
	out := l.copy()
	out.level = level
	return out
}

func (l *rlog) WithName(name string) logr.Logger {
	out := l.copy()
	if out.name == "" {
		out.name = name
	} else {
		out.name = out.name + "/" + name
	}
	return out
}

func (l *rlog) WithFields(kvList ...interface{}) logr.Logger {
	out := l.copy()
	out.fields = append(out.fields, kvList...)
	return out
}

func (l *rlog) output(msg string, kvList ...interface{}) {
	if len(kvList)%2 != 0 {
		panic("fields must be key-value pairs")
	}
	now := time.Now().Format("2006/1/2 15:04:05")
	// callDepth 0 represents current line
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = autoGeneratedName
		line = 0
	}
	str := fmt.Sprintf("I%d %s %s:%d %s [%s] %s %s\n",
		l.level, now, file, line, l.name, msg, flatten(l.fields...), flatten(kvList...))
	os.Stderr.WriteString(str)
}

// kvList must be key-value pair
func flatten(kvList ...interface{}) string {
	dict := kvListToMap(kvList...)
	keys := make([]string, 0, len(dict))
	for k, _ := range dict {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	buf := strings.Builder{}
	sep := ""
	// sortted flatten
	for _, key := range keys {
		buf.WriteString(sep)
		sep = " "
		buf.WriteString(key)
		buf.WriteString("=")
		buf.WriteString(pretty(dict[key]))
	}
	return buf.String()
}

// kvList must be key-value pair
func kvListToMap(kvList ...interface{}) map[string]interface{} {
	dict := make(map[string]interface{})
	for i := 0; i < len(kvList); i += 2 {
		key := kvList[i].(string)
		value := kvList[i+1]
		dict[key] = value
	}
	return dict
}

func pretty(v interface{}) string {
	if _, ok := v.(error); ok {
		return v.(error).Error()
	}
	if reflect.ValueOf(v).Kind() == reflect.Chan {
		return "<chan?>"
	}
	if reflect.ValueOf(v).Kind() == reflect.Ptr {
		v = reflect.Indirect(reflect.ValueOf(v)).Interface()
	}

	return fmt.Sprintf("%v", v)
}
